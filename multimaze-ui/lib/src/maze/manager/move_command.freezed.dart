// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'move_command.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MoveCommandTearOff {
  const _$MoveCommandTearOff();

  MoveCommandUp up() {
    return const MoveCommandUp();
  }

  MoveCommandDown down() {
    return const MoveCommandDown();
  }

  MoveCommandLeft left() {
    return const MoveCommandLeft();
  }

  MoveCommandRight right() {
    return const MoveCommandRight();
  }
}

/// @nodoc
const $MoveCommand = _$MoveCommandTearOff();

/// @nodoc
mixin _$MoveCommand {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MoveCommandUp value) up,
    required TResult Function(MoveCommandDown value) down,
    required TResult Function(MoveCommandLeft value) left,
    required TResult Function(MoveCommandRight value) right,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MoveCommandCopyWith<$Res> {
  factory $MoveCommandCopyWith(
          MoveCommand value, $Res Function(MoveCommand) then) =
      _$MoveCommandCopyWithImpl<$Res>;
}

/// @nodoc
class _$MoveCommandCopyWithImpl<$Res> implements $MoveCommandCopyWith<$Res> {
  _$MoveCommandCopyWithImpl(this._value, this._then);

  final MoveCommand _value;
  // ignore: unused_field
  final $Res Function(MoveCommand) _then;
}

/// @nodoc
abstract class $MoveCommandUpCopyWith<$Res> {
  factory $MoveCommandUpCopyWith(
          MoveCommandUp value, $Res Function(MoveCommandUp) then) =
      _$MoveCommandUpCopyWithImpl<$Res>;
}

/// @nodoc
class _$MoveCommandUpCopyWithImpl<$Res> extends _$MoveCommandCopyWithImpl<$Res>
    implements $MoveCommandUpCopyWith<$Res> {
  _$MoveCommandUpCopyWithImpl(
      MoveCommandUp _value, $Res Function(MoveCommandUp) _then)
      : super(_value, (v) => _then(v as MoveCommandUp));

  @override
  MoveCommandUp get _value => super._value as MoveCommandUp;
}

/// @nodoc

class _$MoveCommandUp implements MoveCommandUp {
  const _$MoveCommandUp();

  @override
  String toString() {
    return 'MoveCommand.up()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MoveCommandUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
  }) {
    return up();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
  }) {
    return up?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    required TResult orElse(),
  }) {
    if (up != null) {
      return up();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MoveCommandUp value) up,
    required TResult Function(MoveCommandDown value) down,
    required TResult Function(MoveCommandLeft value) left,
    required TResult Function(MoveCommandRight value) right,
  }) {
    return up(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
  }) {
    return up?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
    required TResult orElse(),
  }) {
    if (up != null) {
      return up(this);
    }
    return orElse();
  }
}

abstract class MoveCommandUp implements MoveCommand {
  const factory MoveCommandUp() = _$MoveCommandUp;
}

/// @nodoc
abstract class $MoveCommandDownCopyWith<$Res> {
  factory $MoveCommandDownCopyWith(
          MoveCommandDown value, $Res Function(MoveCommandDown) then) =
      _$MoveCommandDownCopyWithImpl<$Res>;
}

/// @nodoc
class _$MoveCommandDownCopyWithImpl<$Res>
    extends _$MoveCommandCopyWithImpl<$Res>
    implements $MoveCommandDownCopyWith<$Res> {
  _$MoveCommandDownCopyWithImpl(
      MoveCommandDown _value, $Res Function(MoveCommandDown) _then)
      : super(_value, (v) => _then(v as MoveCommandDown));

  @override
  MoveCommandDown get _value => super._value as MoveCommandDown;
}

/// @nodoc

class _$MoveCommandDown implements MoveCommandDown {
  const _$MoveCommandDown();

  @override
  String toString() {
    return 'MoveCommand.down()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MoveCommandDown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
  }) {
    return down();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
  }) {
    return down?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    required TResult orElse(),
  }) {
    if (down != null) {
      return down();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MoveCommandUp value) up,
    required TResult Function(MoveCommandDown value) down,
    required TResult Function(MoveCommandLeft value) left,
    required TResult Function(MoveCommandRight value) right,
  }) {
    return down(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
  }) {
    return down?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
    required TResult orElse(),
  }) {
    if (down != null) {
      return down(this);
    }
    return orElse();
  }
}

abstract class MoveCommandDown implements MoveCommand {
  const factory MoveCommandDown() = _$MoveCommandDown;
}

/// @nodoc
abstract class $MoveCommandLeftCopyWith<$Res> {
  factory $MoveCommandLeftCopyWith(
          MoveCommandLeft value, $Res Function(MoveCommandLeft) then) =
      _$MoveCommandLeftCopyWithImpl<$Res>;
}

/// @nodoc
class _$MoveCommandLeftCopyWithImpl<$Res>
    extends _$MoveCommandCopyWithImpl<$Res>
    implements $MoveCommandLeftCopyWith<$Res> {
  _$MoveCommandLeftCopyWithImpl(
      MoveCommandLeft _value, $Res Function(MoveCommandLeft) _then)
      : super(_value, (v) => _then(v as MoveCommandLeft));

  @override
  MoveCommandLeft get _value => super._value as MoveCommandLeft;
}

/// @nodoc

class _$MoveCommandLeft implements MoveCommandLeft {
  const _$MoveCommandLeft();

  @override
  String toString() {
    return 'MoveCommand.left()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MoveCommandLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
  }) {
    return left();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
  }) {
    return left?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MoveCommandUp value) up,
    required TResult Function(MoveCommandDown value) down,
    required TResult Function(MoveCommandLeft value) left,
    required TResult Function(MoveCommandRight value) right,
  }) {
    return left(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
  }) {
    return left?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left(this);
    }
    return orElse();
  }
}

abstract class MoveCommandLeft implements MoveCommand {
  const factory MoveCommandLeft() = _$MoveCommandLeft;
}

/// @nodoc
abstract class $MoveCommandRightCopyWith<$Res> {
  factory $MoveCommandRightCopyWith(
          MoveCommandRight value, $Res Function(MoveCommandRight) then) =
      _$MoveCommandRightCopyWithImpl<$Res>;
}

/// @nodoc
class _$MoveCommandRightCopyWithImpl<$Res>
    extends _$MoveCommandCopyWithImpl<$Res>
    implements $MoveCommandRightCopyWith<$Res> {
  _$MoveCommandRightCopyWithImpl(
      MoveCommandRight _value, $Res Function(MoveCommandRight) _then)
      : super(_value, (v) => _then(v as MoveCommandRight));

  @override
  MoveCommandRight get _value => super._value as MoveCommandRight;
}

/// @nodoc

class _$MoveCommandRight implements MoveCommandRight {
  const _$MoveCommandRight();

  @override
  String toString() {
    return 'MoveCommand.right()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is MoveCommandRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
  }) {
    return right();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
  }) {
    return right?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MoveCommandUp value) up,
    required TResult Function(MoveCommandDown value) down,
    required TResult Function(MoveCommandLeft value) left,
    required TResult Function(MoveCommandRight value) right,
  }) {
    return right(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
  }) {
    return right?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MoveCommandUp value)? up,
    TResult Function(MoveCommandDown value)? down,
    TResult Function(MoveCommandLeft value)? left,
    TResult Function(MoveCommandRight value)? right,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right(this);
    }
    return orElse();
  }
}

abstract class MoveCommandRight implements MoveCommand {
  const factory MoveCommandRight() = _$MoveCommandRight;
}
